<!DOCTYPE html>
<html>

<head>
    <title>TR-808 Emulator</title>
    <style>
        .drum-machine {
            padding: 20px;
            background: #333;
            display: inline-block;
        }

        button {
            padding: 10px;
            margin: 5px;
            width: 100px;
            background: #444;
            color: white;
            border: none;
            cursor: pointer;
        }

        button:hover {
            background: #555;
        }
    </style>
</head>

<body>
    <div class="drum-machine">
        <button id="bd">Bass Drum</button>
        <button id="sd">Snare</button>
        <button id="lt">Low Tom</button>
        <button id="mt">Mid Tom</button>
        <button id="ht">High Tom</button>
        <button id="rs">Rim Shot</button>
        <button id="cl">Claves</button>
        <button id="cp">Clap</button>
        <button id="ma">Maracas</button>
        <button id="cb">Cowbell</button>
        <button id="cy">Cymbal</button>
        <button id="oh">Open HiHat</button>
        <button id="ch">Closed HiHat</button>
        <button id="accent">Accent</button>
    </div>

    <script>
        let audioContext;
        let accentGain = 1;

        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function createNoiseBuffer(context) {
            const bufferSize = 2 * context.sampleRate;
            const buffer = context.createBuffer(1, bufferSize, context.sampleRate);
            const output = buffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            return buffer;
        }

        function playSound(soundFn) {
            initAudioContext();
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            soundFn(audioContext);
        }

        // Sound generators
        const sounds = {
            bd: (context) => {
                const osc = context.createOscillator();
                const gain = context.createGain();
                const filter = context.createBiquadFilter();

                osc.type = 'sine';
                filter.type = 'lowpass';
                filter.frequency.value = 60;

                osc.frequency.setValueAtTime(150, context.currentTime);
                osc.frequency.exponentialRampToValueAtTime(0.01, context.currentTime + 0.3);

                gain.gain.setValueAtTime(1 * accentGain, context.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, context.currentTime + 0.5);

                osc.connect(filter).connect(gain).connect(context.destination);
                osc.start();
                osc.stop(context.currentTime + 0.5);
            },

            sd: (context) => {
                const mainGain = context.createGain();
                const noiseGain = context.createGain();
                const snappy = .9; // 0-1 control for noise amount
                const toneValue = 0.; // Control mix of frequencies
                const fundamentalFreq = 250; // Fundamental frequency of snare drum
                const harmonicFreq = 500;    // Second harmonic frequency
                const noiseFilterFreq = 2000; //Frequency of noise HPF
                const mainDecay = 0.15 //Main decay of synth
                const noiseDecay = 0.3 //Noise decay of synth

                // Create oscillators for fundamental and harmonic frequencies
                const fundamentalOsc = context.createOscillator();
                fundamentalOsc.type = 'sine';
                fundamentalOsc.frequency.value = fundamentalFreq;

                const harmonicOsc = context.createOscillator();
                harmonicOsc.type = 'sine';
                harmonicOsc.frequency.value = harmonicFreq;

                // Create gain nodes for tone control
                const fundamentalGain = context.createGain();
                const harmonicGain = context.createGain();

                // Set gain values based on tone control
                fundamentalGain.gain.value = 1 - toneValue; // Fundamental decreases as tone increases
                harmonicGain.gain.value = toneValue;       // Harmonic increases as tone increases

                // Noise source with HPF
                const noise = context.createBufferSource();
                noise.buffer = createNoiseBuffer(context);
                const noiseFilter = context.createBiquadFilter();
                noiseFilter.type = 'highpass';
                noiseFilter.frequency.value = noiseFilterFreq;

                // Envelopes
                mainGain.gain.setValueAtTime(1 * accentGain, context.currentTime);
                mainGain.gain.exponentialRampToValueAtTime(0.001, context.currentTime + mainDecay);

                noiseGain.gain.setValueAtTime(snappy, context.currentTime);
                noiseGain.gain.exponentialRampToValueAtTime(0.001, context.currentTime + noiseDecay);

                // Connect components
                noise.connect(noiseFilter).connect(noiseGain).connect(mainGain);
                fundamentalOsc.connect(fundamentalGain).connect(mainGain);
                harmonicOsc.connect(harmonicGain).connect(mainGain);

                mainGain.connect(context.destination);

                // Start oscillators
                fundamentalOsc.start();
                harmonicOsc.start();
                noise.start();
                fundamentalOsc.stop(context.currentTime + 0.3);
                harmonicOsc.stop(context.currentTime + 0.3);
                noise.stop(context.currentTime + 0.3);
            },

            lt: (context) => {
                const osc = context.createOscillator();
                const gain = context.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(100, context.currentTime);
                osc.frequency.exponentialRampToValueAtTime(0.01, context.currentTime + 0.5);

                gain.gain.setValueAtTime(0.7 * accentGain, context.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, context.currentTime + 0.7);

                osc.connect(gain).connect(context.destination);
                osc.start();
                osc.stop(context.currentTime + 0.7);
            },

            mt: (context) => {
                const osc = context.createOscillator();
                const gain = context.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, context.currentTime);
                osc.frequency.exponentialRampToValueAtTime(0.01, context.currentTime + 0.4);

                gain.gain.setValueAtTime(0.7 * accentGain, context.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, context.currentTime + 0.6);

                osc.connect(gain).connect(context.destination);
                osc.start();
                osc.stop(context.currentTime + 0.6);
            },

            ht: (context) => {
                const osc = context.createOscillator();
                const gain = context.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(300, context.currentTime);
                osc.frequency.exponentialRampToValueAtTime(0.01, context.currentTime + 0.3);

                gain.gain.setValueAtTime(0.7 * accentGain, context.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, context.currentTime + 0.5);

                osc.connect(gain).connect(context.destination);
                osc.start();
                osc.stop(context.currentTime + 0.5);
            },

            rs: (context) => {
                const noise = context.createBufferSource();
                const filter = context.createBiquadFilter();
                const gain = context.createGain();

                noise.buffer = createNoiseBuffer(context);
                filter.type = 'bandpass';
                filter.frequency.value = 1500;

                gain.gain.setValueAtTime(0.8 * accentGain, context.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, context.currentTime + 0.1);

                noise.connect(filter).connect(gain).connect(context.destination);
                noise.start();
                noise.stop(context.currentTime + 0.1);
            },

            cl: (context) => {
                const noise = context.createBufferSource();
                const filter = context.createBiquadFilter();
                const gain = context.createGain();

                noise.buffer = createNoiseBuffer(context);
                filter.type = 'bandpass';
                filter.frequency.value = 2000;
                filter.Q.value = 10;

                gain.gain.setValueAtTime(0.8 * accentGain, context.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, context.currentTime + 0.2);

                noise.connect(filter).connect(gain).connect(context.destination);
                noise.start();
                noise.stop(context.currentTime + 0.2);
            },

            cp: (context) => {
                const noise = context.createBufferSource();
                const filter = context.createBiquadFilter();
                const gain = context.createGain();

                noise.buffer = createNoiseBuffer(context);
                filter.type = 'bandpass';
                filter.frequency.value = 1200;

                gain.gain.setValueAtTime(0.7 * accentGain, context.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, context.currentTime + 0.4);

                noise.connect(filter).connect(gain).connect(context.destination);
                noise.start();
                noise.stop(context.currentTime + 0.4);
            },

            ma: (context) => {
                const noise = context.createBufferSource();
                const filter = context.createBiquadFilter();
                const gain = context.createGain();

                noise.buffer = createNoiseBuffer(context);
                filter.type = 'highpass';
                filter.frequency.value = 3000;

                gain.gain.setValueAtTime(0.6 * accentGain, context.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, context.currentTime + 0.3);

                noise.connect(filter).connect(gain).connect(context.destination);
                noise.start();
                noise.stop(context.currentTime + 0.3);
            },

            cb: (context) => {
                const osc1 = context.createOscillator();
                const osc2 = context.createOscillator();
                const gain = context.createGain();
                const filter = context.createBiquadFilter();

                // Oscillator types and frequencies
                osc1.type = 'square';  // First oscillator
                osc1.frequency.value = 540;

                osc2.type = 'square';  // Second oscillator
                osc2.frequency.value = 800;

                // Envelope settings
                gain.gain.setValueAtTime(0, context.currentTime);
                gain.gain.linearRampToValueAtTime(0.9 * accentGain, context.currentTime + 0.01); // Short attack
                gain.gain.exponentialRampToValueAtTime(0.01, context.currentTime + 0.25); // Medium release

                // Optional bandpass filter
                filter.type = 'bandpass';
                filter.frequency.value = 1200;
                filter.Q.value = 8;

                // Connect oscillators
                osc1.connect(gain);
                osc2.connect(gain);
                gain.connect(filter).connect(context.destination);

                // Start and stop oscillators
                osc1.start();
                osc2.start();
                osc1.stop(context.currentTime + 0.3);
                osc2.stop(context.currentTime + 0.3);
            },

            cy: (context) => {
                const mainGain = context.createGain();
                const noise = context.createBufferSource();
                noise.buffer = createNoiseBuffer(context);

                // Create filters
                const hp = context.createBiquadFilter();
                const lp = context.createBiquadFilter();

                hp.type = 'highpass';
                hp.frequency.value = 8000;

                lp.type = 'lowpass';
                lp.frequency.value = 12000;

                // Create envelope
                const env = context.createGain();
                env.gain.setValueAtTime(0.5 * accentGain, context.currentTime);
                env.gain.exponentialRampToValueAtTime(0.01, context.currentTime + 0.5);

                // Connect components
                noise.connect(hp).connect(lp).connect(env).connect(context.destination);

                // Start and stop
                noise.start();
                noise.stop(context.currentTime + 0.5);
            },

            oh: (context) => {
                const mainGain = context.createGain();
                const noise = context.createBufferSource();
                noise.buffer = createNoiseBuffer(context);

                // Create high-pass filters
                const hp1 = context.createBiquadFilter();
                const hp2 = context.createBiquadFilter();

                hp1.type = 'highpass';
                hp1.frequency.value = 6000;

                hp2.type = 'highpass';
                hp2.frequency.value = 8000;

                // Create envelope
                const env = context.createGain();
                env.gain.setValueAtTime(0.5 * accentGain, context.currentTime);
                env.gain.exponentialRampToValueAtTime(0.01, context.currentTime + 0.6);

                // Connect components
                noise.connect(hp1).connect(hp2).connect(env).connect(context.destination);

                // Start and stop
                noise.start();
                noise.stop(context.currentTime + 0.7);
            },

            ch: (context) => {
                const frequencies = [204, 298, 366, 515, 540, 800];
                const oscillators = [];
                const bandpass = context.createBiquadFilter();
                const highpass = context.createBiquadFilter();
                const lowpass = context.createBiquadFilter();
                const env = context.createGain();

                // Set filter parameters
                bandpass.type = 'bandpass';
                bandpass.frequency.value = 8500; // Slightly higher for closed hat
                bandpass.Q.value = 9;

                highpass.type = 'highpass';
                highpass.frequency.value = 6500;
                highpass.Q.value = 7;

                lowpass.type = 'lowpass';
                lowpass.frequency.value = 8600;
                lowpass.Q.value = 3;

                // Create envelope with specified decay, sustain, and release times
                env.gain.setValueAtTime(0.6 * accentGain, context.currentTime);
                env.gain.exponentialRampToValueAtTime(0.01, context.currentTime + 0.1); // Decay time = 40ms
                env.gain.linearRampToValueAtTime(0, context.currentTime + 0.04); // Sustain = 0
                env.gain.exponentialRampToValueAtTime(0.01, context.currentTime + 0.15); // Release time = 100ms

                // Create oscillators with frequency jitter and detuning
                frequencies.forEach(freq => {
                    const osc = context.createOscillator();
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(freq, context.currentTime);

                    // Add frequency modulation and jitter
                    const mod = context.createOscillator();
                    mod.type = 'sine';
                    mod.frequency.setValueAtTime(0.01 * freq, context.currentTime);

                    const noise = context.createBufferSource();
                    noise.buffer = createNoiseBuffer(context);

                    // Modulate frequency
                    const sum = context.createGain();
                    sum.gain.setValueAtTime(1.005, context.currentTime);
                    mod.connect(sum);
                    noise.connect(sum);
                    sum.connect(osc.frequency);

                    // Add drift to oscillator frequency
                    const time = context.currentTime;
                    osc.frequency.exponentialRampToValueAtTime(freq * 1.002, time + 0.1);
                    osc.frequency.exponentialRampToValueAtTime(freq * 0.998, time + 0.2);

                    osc.connect(bandpass);
                    bandpass.connect(highpass);
                    highpass.connect(lowpass);
                    lowpass.connect(env);
                    env.connect(context.destination);

                    oscillators.push(osc);
                });

                // Start and stop oscillators
                oscillators.forEach(osc => {
                    osc.start();
                    osc.stop(context.currentTime + 0.1);
                });
            }
        };

        // Add event listeners
        document.querySelectorAll('button').forEach(button => {
            button.addEventListener('click', (e) => {
                if (e.target.id === 'accent') {
                    accentGain = 2;
                    setTimeout(() => accentGain = 1, 50);
                } else if (sounds[e.target.id]) {
                    playSound(sounds[e.target.id]);
                }
            });
        });
    </script>
</body>

</html>