<!DOCTYPE html>
<html>

<head>
    <title>DX7 HLE Emulator</title>
    <style>
        .container {
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
            font-family: Arial, sans-serif;
        }

        .keyboard {
            display: flex;
            height: 100px;
            margin: 20px 0;
        }

        .key {
            border: 1px solid #000;
            width: 20px;
            margin: 0 1px;
            background: white;
            cursor: pointer;
        }

        .key.active {
            background: #ccc;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        button {
            padding: 10px;
        }

        .file-upload {
            margin-top: 20px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>DX7 HLE Emulator</h1>
        <div class="keyboard" id="keyboard"></div>
        <div class="controls">
            <button id="init">Initialize Audio</button>
            <select id="algorithm">
                <option value="1">Algorithm 1</option>
                <option value="2">Algorithm 2</option>
                <option value="3">Algorithm 3</option>
                <option value="4">Algorithm 4</option>
                <option value="5">Algorithm 5</option>
                <option value="7">Algorithm 7</option>
                <option value="8">Algorithm 8</option>
                <option value="16">Algorithm 16</option>
                <option value="20">Algorithm 20</option>
                <option value="21">Algorithm 21</option>
                <option value="22">Algorithm 22</option>
                <option value="23">Algorithm 23</option>
                <option value="24">Algorithm 24</option>
                <option value="25">Algorithm 25</option>
                <option value="26">Algorithm 26</option>
                <option value="29">Algorithm 29</option>
                <option value="30">Algorithm 30</option>
                <option value="32">Algorithm 32</option>
            </select>
        </div>

        <!-- File Upload for DX7 Cartridge -->
        <div class="file-upload">
            <h2>Upload DX7 Cartridge File</h2>
            <input type="file" id="cartridge-file" accept=".syx" />
            <p>Upload a .syx file to load patches from a DX7 cartridge.</p>
        </div>

        <!-- Patch Selector -->
        <div class="patch-selector">
            <h2>Loaded Patches</h2>
            <select id="patch-select" disabled>
                <option value="">Load a cartridge to select patches</option>
            </select>
        </div>
    </div>

    <script>
        class DX7Emulator {
            constructor() {
                this.audioContext = null;
                this.operators = [];
                this.activeNotes = new Map();
                this.lfo = null;
                this.algorithm = 1;
                this.patches = []; // Stores loaded patches from the cartridge
                this.currentPatch = null; // Stores the currently loaded patch
                this.globalParams = {}; // Add global parameters storage
            }

            initialize() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    // Explicitly resume to handle browser autoplay policies
                    this.audioContext.resume().then(() => {
                        this.createLFO();
                        console.log("Audio initialized and resumed");
                    });
                }
            }

            createLFO() {
                this.lfo = this.audioContext.createOscillator();
                const lfoGain = this.audioContext.createGain();
                lfoGain.gain.value = this.globalParams.lfoPitchModDepth / 64; // Normalize
                this.lfo.connect(lfoGain);
                this.lfo.frequency.value = this.globalParams.lfoSpeed / 16; // Adjust scaling

                // Apply LFO to all operators' frequencies
                this.operators.forEach((op, index) => {
                    lfoGain.connect(op.oscillator.frequency);
                });
                this.lfo.start();
            }

            setAlgorithm(index) {
                this.algorithm = parseInt(index, 10);
                console.log(`Algorithm set to ${this.algorithm}`);
            }

            applyPatch(patchIndex) {
                if (patchIndex < 0 || patchIndex >= this.patches.length) return;
                const patch = this.patches[patchIndex];
                this.currentPatch = patch;

                const data = new Uint8Array(patch.data);
                this.globalParams = {
                    algorithm: data[134] & 0x1f, // Correct algorithm position
                    feedback: (data[135] >> 3) & 0x07,
                    lfoSpeed: data[144],
                    lfoDelay: data[145],
                    lfoPitchModDepth: data[146],
                    lfoAmpModDepth: data[147]
                };

                // Update algorithm from patch data instead of UI
                this.setAlgorithm(this.globalParams.algorithm);
                document.getElementById('algorithm').value = this.globalParams.algorithm;

                // Parse all 6 operators
                this.operators = [];
                for (let op = 0; op < 6; op++) {
                    const offset = op * 21; // Correct DX7 operator offset
                    this.operators[op] = {
                        egRates: {
                            attack: data[offset] / 16,
                            decay1: data[offset + 1] / 16,
                            decay2: data[offset + 2] / 16,
                            release: data[offset + 3] / 16
                        },
                        egLevels: {
                            level1: data[offset + 4],
                            level2: data[offset + 5],
                            level3: data[offset + 6]
                        },
                        breakPoint: data[offset + 7],
                        keyScale: data[offset + 8],
                        rateScaling: data[offset + 9],
                        outputLevel: data[offset + 10],
                        mode: data[offset + 11],
                        freqCoarse: data[offset + 12],
                        freqFine: data[offset + 13],
                        detune: data[offset + 14] & 0x07
                    };
                }
                console.log("Patch applied:", patch.name);
            }

            createOperator(opIndex) {
                const opParams = this.operators[5 - opIndex]; // Operators are reversed in DX7
                const now = this.audioContext.currentTime;

                const oscillator = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                const freqCoarse = opParams.freqCoarse;
                const freqFine = opParams.freqFine / 100; // 0â€“1.0
                const frequency = 440 * Math.pow(2, (freqCoarse - 69)/12 + freqFine);

                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(frequency, now);

                // Apply envelope
                const env = opParams.egRates;
                const levels = opParams.egLevels;
                gain.gain.setValueCurveAtTime(
                    [0, 1, levels.level1/100, levels.level2/100],
                    now,
                    env.attack + env.decay1 + env.decay2
                );

                return { oscillator, gain, releaseTime: env.release };
            }

            triggerNote(frequency) {
                if (!this.audioContext) return;

                const operators = Array.from({ length: 6 }, (_, i) => this.createOperator(i));
                this.configureAlgorithm(operators, frequency);

                operators.forEach(op => {
                    op.oscillator.start();
                    op.gain.connect(this.audioContext.destination);
                });

                this.activeNotes.set(frequency, {
                    operators,
                    stop: () => operators.forEach(op => {
                        op.gain.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + op.releaseTime);
                        op.oscillator.stop(this.audioContext.currentTime + op.releaseTime + 0.1);
                    })
                });
            }

            releaseNote(frequency) {
                const note = this.activeNotes.get(frequency);
                if (note) {
                    note.stop();
                    this.activeNotes.delete(frequency);
                }
            }

            loadCartridgeFile(file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const data = new Uint8Array(event.target.result);
                    console.log("File size:", data.length);
                    console.log("First few bytes:", data.slice(0, 10));

                    // Check for SysEx headers
                    if (data[0] === 0xF0 && data[data.length - 1] === 0xF7) {
                        // Parse the SysEx file
                        this.parseCartridgeData(data);
                    } else {
                        console.error("Invalid SysEx file. Expected F0 at start and F7 at end.");
                    }
                };
                reader.readAsArrayBuffer(file);
            }

            parseCartridgeData(data) {
                let offset = 0;
                // Skip SysEx header (F0 ... F7)
                while (data[offset] !== 0xF0) offset++;
                while (data[offset] !== 0xF7) offset++;
                offset++; // Move past F7

                // Extract the 32 patches from the SysEx file
                this.patches = [];
                const patchSize = 128; // Each patch is 128 bytes

                for (let i = 0; i < 32; i++) {
                    const patchData = data.slice(offset + i * patchSize, offset + (i + 1) * patchSize);
                    const nameData = new Uint8Array(patchData.slice(118, 128));
                    let patchName = '';
                    nameData.forEach(byte => {
                        patchName += String.fromCharCode(byte);
                    });
                    this.patches.push({
                        name: patchName.trim(),
                        data: patchData
                    });
                }

                // Dispatch event to update UI
                const event = new CustomEvent('patches-loaded', { detail: this.patches });
                document.dispatchEvent(event);
                console.log("Loaded 32 patches from cartridge file");
            }

            configureAlgorithm(operators, frequency) {
                const carriers = [];
                const modulators = [];

                switch (this.algorithm) {
                    case 1:
                        modulators.push(
                            { from: 5, to: 4 }, { from: 4, to: 3 }, { from: 1, to: 0 }
                        );
                        carriers.push(0, 3);
                        break;
                    case 2:
                        modulators.push(
                            { from: 5, to: 4 }, { from: 4, to: 3 },
                            { from: 2, to: 1 }, { from: 1, to: 0 }
                        );
                        // Apply feedback to operator 3
                        const feedbackGain = this.audioContext.createGain();
                        feedbackGain.gain.value = this.globalParams.feedback / 7; // Scale 0â€“7
                        operators[3].gain.connect(feedbackGain);
                        feedbackGain.connect(operators[3].oscillator.frequency);
                        carriers.push(3, 0);
                        break;
                    case 3:
                        modulators.push(
                            { from: 1, to: 0 }, { from: 2, to: 0 }, { from: 5, to: 4 }
                        );
                        carriers.push(0, 4);
                        break;
                    case 4:
                        modulators.push(
                            { from: 1, to: 0 }, { from: 2, to: 0 },
                            { from: 4, to: 3 }, { from: 5, to: 3 }
                        );
                        carriers.push(0, 3);
                        break;
                    case 5:
                        modulators.push(
                            { from: 1, to: 0 }, { from: 3, to: 2 }, { from: 5, to: 4 }
                        );
                        carriers.push(0, 2, 4);
                        break;
                    case 7:
                        modulators.push(
                            { from: 1, to: 0 }, { from: 2, to: 0 },
                            { from: 3, to: 0 }, { from: 4, to: 0 }, { from: 5, to: 0 }
                        );
                        carriers.push(0);
                        break;
                    case 8:
                        modulators.push(
                            { from: 1, to: 0 }, { from: 3, to: 2 },
                            { from: 4, to: 2 }, { from: 5, to: 4 }
                        );
                        operators[3].gain.connect(operators[3].oscillator.frequency);
                        carriers.push(0, 2);
                        break;
                    case 16:
                        modulators.push(
                            { from: 1, to: 0 }, { from: 2, to: 0 },
                            { from: 4, to: 3 }, { from: 5, to: 3 }
                        );
                        carriers.push(0, 3);
                        break;
                    case 20:
                        modulators.push(
                            { from: 1, to: 0 }, { from: 3, to: 0 }, { from: 5, to: 4 }
                        );
                        carriers.push(0, 2, 4);
                        break;
                    case 21:
                        modulators.push(
                            { from: 2, to: 1 }, { from: 3, to: 0 }, { from: 5, to: 4 }
                        );
                        carriers.push(0, 2, 4);
                        break;
                    case 22:
                        modulators.push(
                            { from: 3, to: 2 }, { from: 4, to: 1 }, { from: 5, to: 0 }
                        );
                        carriers.push(0, 1, 2);
                        break;
                    case 23:
                        modulators.push(
                            { from: 1, to: 0 }, { from: 2, to: 0 }, { from: 5, to: 4 }
                        );
                        carriers.push(0, 4);
                        break;
                    case 24:
                        modulators.push(
                            { from: 1, to: 0 }, { from: 3, to: 0 },
                            { from: 2, to: 5 }, { from: 4, to: 5 }
                        );
                        carriers.push(0, 5);
                        break;
                    case 25:
                        carriers.push(0, 2, 4);
                        break;
                    case 26:
                        modulators.push(
                            { from: 1, to: 0 }, { from: 2, to: 3 }, { from: 4, to: 5 }
                        );
                        operators[5].gain.connect(operators[5].oscillator.frequency);
                        carriers.push(0, 3, 5);
                        break;
                    case 29:
                        modulators.push(
                            { from: 3, to: 0 }, { from: 1, to: 4 }, { from: 2, to: 4 }
                        );
                        carriers.push(0, 4);
                        break;
                    case 30:
                        modulators.push(
                            { from: 3, to: 4 }, { from: 0, to: 5 },
                            { from: 1, to: 5 }, { from: 2, to: 5 }
                        );
                        carriers.push(4, 5);
                        break;
                    case 32:
                        carriers.push(0, 1, 2, 3, 4, 5);
                        break;
                    default:
                        console.error("Invalid algorithm selected");
                        return;
                }

                carriers.forEach(index => {
                    operators[index].gain.connect(this.audioContext.destination);
                });

                modulators.forEach(({ from, to }) => {
                    operators[from].gain.connect(operators[to].oscillator.frequency);
                });
            }
        }

        // UI Setup
        document.addEventListener('DOMContentLoaded', () => {
            const emulator = new DX7Emulator();
            const keyboard = document.getElementById('keyboard');
            const notes = [60, 62, 64, 65, 67, 69, 71]; // MIDI note numbers

            // Create keyboard
            notes.forEach(note => {
                const key = document.createElement('div');
                key.className = 'key';
                key.dataset.note = note;
                key.addEventListener('mousedown', () => {
                    key.classList.add('active');
                    const frequency = 440 * Math.pow(2, (note - 69) / 12);
                    emulator.triggerNote(frequency);
                });
                key.addEventListener('mouseup', () => {
                    key.classList.remove('active');
                    const frequency = 440 * Math.pow(2, (note - 69) / 12);
                    emulator.releaseNote(frequency);
                });
                keyboard.appendChild(key);
            });

            // Initialize Audio
            document.getElementById('init').addEventListener('click', () => {
                emulator.initialize();
            });

            // Change Algorithm
            document.getElementById('algorithm').addEventListener('change', (e) => {
                emulator.setAlgorithm(e.target.value);
            });

            // Upload Cartridge File
            document.getElementById('cartridge-file').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    emulator.loadCartridgeFile(file);
                }
            });

            // Handle patches-loaded event
            document.addEventListener('patches-loaded', (e) => {
                const patchSelect = document.getElementById('patch-select');
                patchSelect.innerHTML = '';
                e.detail.forEach((patch, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = `${index + 1}: ${patch.name}`;
                    patchSelect.appendChild(option);
                });
                patchSelect.disabled = false;
            });

            // Handle patch selection
            document.getElementById('patch-select').addEventListener('change', (e) => {
                const index = parseInt(e.target.value, 10);
                if (!isNaN(index) && index >= 0 && index < emulator.patches.length) {
                    emulator.applyPatch(index);
                }
            });
        });
    </script>
</body>

</html>